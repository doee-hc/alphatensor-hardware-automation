# -*- coding: utf-8 -*-
"""Explore factorizations

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/deepmind/alphatensor/blob/master/algorithms/explore_factorizations.ipynb

Loading factorizations found by AlphaTensor and recombination.

- Copyright 2022 DeepMind Technologies Limited
- All software is licensed under the Apache License, Version 2.0 (Apache 2.0); you may not use this file except in compliance with the Apache 2.0 license. You may obtain a copy of the Apache 2.0 license at: https://www.apache.org/licenses/LICENSE-2.0
- All other materials are licensed under the Creative Commons Attribution 4.0 International License (CC-BY).  You may obtain a copy of the CC-BY license at: https://creativecommons.org/licenses/by/4.0/legalcode
- Unless required by applicable law or agreed to in writing, all software and materials distributed here under the Apache 2.0 or CC-BY licenses are distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the licenses for the specific language governing permissions and limitations under those licenses.
- This is not an official Google product.
"""

import numpy as np
import dict_analyze
import pandas as pd
import sys

# from google.colab import files

"""Upload one of the two files provided in the same folder: `factorization_r.npz` (algorithms in standard arithmetic) or `factorization_f2.npz` (algorithms in arithmetic modulo 2)."""

#uploaded = files.upload()
#filename = list(uploaded.keys())[0]
filename = 'factorizations_r.npz'
with open(filename, 'rb') as f:
  factorizations = dict(np.load(f, allow_pickle=True))

# np 打印参数
np.set_printoptions(threshold=np.inf)

if len(sys.argv) == 4:  # 脚本名也算一个参数，所以检查长度是否为4
    script_name, n, m, p = sys.argv
    n, m, p = int(n), int(m), int(p)    

# Print available factorizations and their shapes.
for key in factorizations:
  u, v, w = factorizations[key]
  rank = u.shape[-1]
  assert rank == v.shape[-1] and rank == w.shape[-1]
  #print(f'{key}: rank={u.shape[-1]}')

  if(key==f'{n},{m},{p}'):


    arr0 =  np.random.rand(n, m)
    arr1 =  np.random.rand(m, p)
    res = dict_analyze.algorithm_verify(u,v,w,arr0,arr1)

    dict_analyze.print_equations(u,v,w)
    u_df = pd.DataFrame(u)
    v_df = pd.DataFrame(v)
    w_df = pd.DataFrame(w)
    u_df.to_excel('u_sheet.xlsx', index=False, header=False)
    v_df.to_excel('v_sheet.xlsx', index=False, header=False)
    w_df.to_excel('w_sheet.xlsx', index=False, header=False)

    res_ref = np.dot(arr0, arr1)
    #result_eq = np.array_equal(res0, res1)
    result_eq = np.allclose(res, res_ref)
    print(f"arr0:\r\n{arr0}")
    print(f"arr1:\r\n{arr1}")
    print(f"res:\r\n{res}")
    print(f"res_ref:\r\n{res_ref}")
    print(f"\r\nResult: {result_eq}\r\n")

    #excel_gen(u,u_sheet)
    #excel_gen(v,v_sheet)
    #excel_gen(w,w_sheet)

    #with open('table.dat','w') as file:
    #    file.write('u:')
    #    file.write(f'{u}')
    #    file.write('v:')
    #    file.write(f'{v}')
    #    file.write('w:')
    #    file.write(f'{w}')
    #print(f'u:\n{u}')
    #print(f'v:\n{v}')
    #print(f'w:\n{w}')

  #if(key=='9,9,9'):
  #  print(f'u:\n{u}')
  #  print(f'v:\n{v}')
  #  print(f'w:\n{w}')

"""Please note that as provided, the factorizations decompose the *symmetrized* version of the matrix multiplication tensor, representing the bilinear operation $\mathbf{A}, \mathbf{B} \mapsto (\mathbf{A} \cdot \mathbf{B})^T$. This is standard in the literature, and factorizations can be easily converted
between the symmetrized and non-symmetrized versions.
"""

def get_mamu_tensor_rectangular(a: int, b: int, c: int) -> np.ndarray:
  """Returns the symmetrized matrix multiplication tensor T_{a, b, c}."""
  result = np.full((a*b, b*c, c*a), 0, dtype=np.int32)
  for i in range(a):
    for j in range(b):
      for k in range(c):
        result[i * b  + j][j * c + k][k * a + i] = 1
  return result


# Test correctness of a factorization.
tensor = get_mamu_tensor_rectangular(2, 2, 2)
#print('mamu tensor:')
#print(tensor)
u, v, w = factorizations['2,2,2']

#for i in range(4):
#    for j in range(4):
#        for k in range(4):
#            reconstruction[i, j, k] = sum(u[i, r] * v[j, r] * w[k, r] for r in range(7))
reconstruction = np.einsum('ir,jr,kr->ijk', u, v, w)
#print('Reconstruction tensor:')
#print(reconstruction)

#if np.array_equal(tensor, reconstruction):
#  print('Factorization is correct in R (standard arithmetic).')
#elif np.array_equal(tensor, np.mod(reconstruction, 2)):
#  print('Factorization is correct in F2 (modular arithmetic).')
#else:
#  print('Factorization is incorrect.')

